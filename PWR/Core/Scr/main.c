/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
/* Private includes ----------------------------------------------------------*/
#include "RCC.h"
#include "Config.h"
#include "USART.h"
#include "Delay.h"
#include <stdio.h>
/* Private typedef -----------------------------------------------------------*/
#define EXTI_FALLING_IT			1
#define EXTI_RISING_IT			2
#define EXTI_FR_IT				3

#define GPIO_PIN_13				13

/* Private define ------------------------------------------------------------*/


/* Private macro -------------------------------------------------------------*/
#define USE_SWV			0
/* Private variables ---------------------------------------------------------*/

/* Private function prototypes -----------------------------------------------*/
static void EXTI13_Config(uint8_t typeIT);

static void PeripheralEvent(void);


void EntrySleepMode(void){
	//clear SLEEEP bit SCR
	SCB->SCR &=~ (1U<<2);
	//sleep on exit
	SCB->SCR &=~ 1U<<1;
	PeripheralEvent();
	__WFE();
	//__WFI();
	//asm("wfi");
	return;
}

void PeripheralITasEvent(void){
	//ESTABLECER EL BIT SEVONPEND
	SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
	//DISABLE ENABLE BIT ON NVIC
	NVIC_DisableIRQ(EXTI15_10_IRQn);
	/*limpiar los pending bit*/
	NVIC_ClearPendingIRQ(EXTI15_10_IRQn);
	EXTI->PR |= EXTI_PR_PR13;

	return;
}


static void PeripheralEvent(void){
	RCC->AHB1ENR |= GPIOX_CLOCK(BUTTON);
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	/*configurar el pin como entrada*/

	GPIOX_MODER(MODE_DIGITAL_INPUT,BUTTON);
	GPIOX_PUPDR(MODE_PU_NONE,BUTTON);
	/*configurar el registro mask*/
	EXTI->EMR |= EXTI_EMR_EM13;
	/*configurar el borde de disparo del evento*/
	EXTI->FTSR |= EXTI_FTSR_TR13;
	/*configurar el line mapping*/
	SYSCFG->EXTICR[3] &=~ 0xFU<<4;
	SYSCFG->EXTICR[3] |= SYSCFG_EXTICR4_EXTI13_PC;

	return;
}
/*When exiting Stop mode by issuing an interrupt or a
 * wakeup event, the HSI RC oscillator is selected as system clock
 */

void EntryStopMode(void){
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	/* Clear Wakeup flag*/
	PWR->CR |= PWR_CSR_WUF;
	//Wake event
	//PeripheralEvent();
	 /* Disable FLASH Deep Power Down Mode by clearing FPDS bit*/
	PWR->CR |= PWR_CR_FPDS;
	/*select regulator (MR, LPR)*/
	PWR->CR |= PWR_CR_MRLVDS;
	//PDDS
	PWR->CR &=~ (1<<1);
	PWR->CR &=~ (1U);
	//SLEEP DEEP
	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
	//WFI/WFE
	//__WFE();
	__WFI();
	//EXIT STOP MODE
	SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
	return;
}
/* Private user code ---------------------------------------------------------*/


/* External variables --------------------------------------------------------*/


int main(void)
{
	/*delay Init*/
#if USE_DELAY_US == 1
	delay_Init(SystemCoreClock/1000000);
#else
	delay_Init(SystemCoreClock/1000);
#endif
	/*PLL INIT*/

	//usart init
	USART_Init(USART2, 115200);

	//EXTI13
	EXTI13_Config(EXTI_FALLING_IT);
	//PeripheralITasEvent();

	//se entra al modo sleep

    /* Loop forever */
	for(;;){
		/*printf("ENTRANDO AL MODO SLEEP\r\n");
		EntrySleepMode();
		NVIC_ClearPendingIRQ(EXTI15_10_IRQn);
		EXTI->PR |= EXTI_PR_PR13;
		printf("\nSALIENDO DEL MODO SLEEP\r\n\n");*/


/****************************************************************/
		printf("ENTRANDO AL MODO STOP\r\n");
		EntryStopMode();
		printf("\nSALIENDO DEL MODO STOP\r\n\n");

	}
}

static void EXTI13_Config(uint8_t typeIT){
	/*enable clock*/
	RCC->AHB1ENR |= GPIOX_CLOCK(BUTTON);
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	/*configurar el pin como entrada*/

	GPIOX_MODER(MODE_DIGITAL_INPUT,BUTTON);
	GPIOX_PUPDR(MODE_PU_NONE,BUTTON);
	/*configurar el borde que dispara la interrupcion*/
	if(typeIT == EXTI_FALLING_IT)
		EXTI->FTSR |= 1U<<13;
	else if(typeIT == EXTI_RISING_IT)
		EXTI->RTSR |= 1U<<13;
	else{
		EXTI->FTSR |= 1U<<13;
		EXTI->RTSR |= 1U<<13;
	}
	/*habilitar el interrupt mask bit*/
	EXTI->IMR |= 1U<<13;
	/*asignar el pin a la linea EXTI*/
	SYSCFG->EXTICR[3] &=~ 0xFU<<4;
	SYSCFG->EXTICR[3] |= SYSCFG_EXTICR4_EXTI13_PC;
	/*Configurar los registros de la NVIC*/
	NVIC_SetPriority(EXTI15_10_IRQn,1);			//PRIORIDAD 1
	NVIC_EnableIRQ(EXTI15_10_IRQn);				//HABILITA LA INTERRUPCION EXTERNA
	//clear pending bit
	EXTI->PR |= 1u<<13;
	NVIC_ClearPendingIRQ(EXTI15_10_IRQn);

}
/*****************************************************************************/
void GPIO_EXTI_Callback(uint8_t pin){
	if(pin == GPIO_PIN_13){
		//codigo
		printf("EXTI13\r\n");
	}

	return;
}

/******************************************************************************/
int __io_putchar(int ch){
#if (USE_SWV== 1)
	ITM_SendChar((uint32_t)ch);
#else
	uint8_t c = ch & 0xFF;
	while(!(USART2->SR & USART_SR_TXE));  //espera hasta que usart este listo para transmitir otro byte
	USART2->DR = c;
#endif
	return ch;
}
