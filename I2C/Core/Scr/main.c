/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <string.h>
#include <stdint.h>
#include "stm32f4xx.h"
#include "Config.h"
#include "MPU6050.h"
#include "delay.h"


#define I2C1_SCL		B, 8
#define I2C1_SDA		B, 9
#define PCLK1			16E+6
#define I2C1_SLAVE_ADD	0x50


#define MPU_ADD			0x68
/**
 * @brief configuracion de pines usados por el i2c1
 */
void I2C1_GPIOConfig(void);

/*
 * @brief configuracion del i2cx
 */
void I2C_Init(I2C_TypeDef *I2Cx , uint32_t pclk, uint32_t i2c_freq);


/**
 * @funcion de envio de datos
 */
void I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t SlaveAddr,uint8_t *pTxbuffer, uint32_t Len);

/**
 * @brief funcion de recepcion de datos
 */
void I2C_MasterReceiveData(I2C_TypeDef *I2Cx,uint8_t SlaveAddr,uint8_t *pRxbuffer, uint32_t Len);


MPU6050_t MPU6050;

int main(void)
{
	delay_Init();

	RCC->AHB1ENR |= GPIOX_CLOCK(LED);
	GPIOX_MODER(MODE_OUT, LED);
/*************************************************************/
	I2C1_GPIOConfig();
	I2C_Init(I2C1, PCLK1, 100000);
/**************************************************************/
	if (MPU6050_Init(&MPU6050, MPU6050_Device_0, MPU6050_Accelerometer_8G, MPU6050_Gyroscope_250s) == MPU6050_Result_Ok) {
		/* Green LED on */
		GPIOX_ODR(LED) = 1;
	}
	/* Set new gyro sens for device 1 */
	//MPU6050_SetGyroscope(&MPU6050, MPU6050_Gyroscope_1000s);
    /* Loop forever */
	for(;;){
		MPU6050_ReadAll(&MPU6050);
		delay_ms(100);
	}
}

/**
 * @brief configuracion de pines usados por el i2c1
 */
void I2C1_GPIOConfig(void){
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SDA);
	GPIOX_MODER(MODE_ALTER, I2C1_SCL);

	GPIOX_AFR(4,I2C1_SCL);
	GPIOX_AFR(4,I2C1_SDA);

	GPIOX_OTYPER(MODE_OT_OD, I2C1_SCL);
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SDA);

	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SCL);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SDA);

	GPIOX_PUPDR(MODE_PU_UP, I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SDA);

	return;
}

/*
 * @brief configuracion del i2cx
 */
void I2C_Init(I2C_TypeDef *I2Cx , uint32_t pclk, uint32_t i2c_freq){
	uint32_t tempreg = 0;
	uint32_t ccr_value = 0;

	/*habilitar el reloj*/
	if(I2Cx == I2C1)
		RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	else if(I2Cx == I2C2)
		RCC->APB1ENR |= RCC_APB1ENR_I2C2EN;
	else
		RCC->APB1ENR |= RCC_APB1ENR_I2C3EN;
	/*1. entrar al modo reset*/
	I2Cx->CR1 |= 1U<<15;
	/*2. salir del modo reset*/
	I2Cx->CR1 &=~ (1U<<15);
	/*3. establecer el bit de control ack*/
	I2Cx->CR1 |= I2C_CR1_ACK;

	/*4. establecer el campo freq*/
	tempreg = pclk / 1000000U;
	I2Cx->CR2 = (tempreg & 0x3FU);

	/*5. establecer la direccion esclavo del dispositivo*/
	tempreg = I2C1_SLAVE_ADD <<1;
	tempreg |= 1u<<14;
	I2Cx->OAR1 = tempreg;
	/* 6. establecer el valor de CCR segun la frecuencia elegida*/
	tempreg = 0;
	if(i2c_freq == 100000U){
		ccr_value = pclk / ( 2 * i2c_freq);
		tempreg = (ccr_value & 0xFFFU);
	}
	else if(i2c_freq == 400000U){
		tempreg |= I2C_CCR_FS;
		ccr_value = pclk /( 3 * i2c_freq);
		/**
		 * si duty == 1
		 * ccr_value = pclk /( 25 * i2c_freq);
		 */
		tempreg |= ccr_value & 0xFFF;
	}else{

	}

	I2Cx->CCR = tempreg;
	/* 7. configurar el TRISE*/
	if(i2c_freq == 100000U)
		tempreg = pclk / 1000000U + 1;
	else if(i2c_freq == 400000U)
		tempreg = ((pclk * 300) /  1000000000U) + 1;
	else{

	}
	I2Cx->TRISE = tempreg;

	/*8. habilitar el i2c*/
	I2Cx->CR1 |= I2C_CR1_PE;
	return;
}


/**
 * @funcion de envio de datos
 */
void I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t SlaveAddr,uint8_t *pTxbuffer, uint32_t Len){
	volatile uint32_t tmp;
	/*verificar los datos*/
	if(Len <= 0 || pTxbuffer == ((void *)0))
		return;
	/*esperar que linea se libere*/
	while((I2Cx->SR2 & I2C_SR2_BUSY));

	/*generar el start condition*/
	I2Cx->CR1 |= I2C_CR1_START;
	//2. esperar que la condicion de start se haya generado
	while(!(I2Cx->SR1 & I2C_SR1_SB));
	//3. enviar la direccion del esclavo
	SlaveAddr = SlaveAddr <<1 ;				//A7-A1 (R/W)
	SlaveAddr &=~(1U);						//write operation
	I2Cx->DR = SlaveAddr;
	//4. Verificamos que la fase de direccion se complete
	while(!(I2Cx->SR1 & I2C_SR1_ADDR));

	//5. limpiar el flag
	tmp = I2Cx->SR1;
	tmp = I2Cx->SR2;
	(void)tmp;

	//6. enviar los datos
	while(Len > 0){

		while(!(I2Cx->SR1 & I2C_SR1_TXE));
		I2Cx->DR = *pTxbuffer;
		pTxbuffer++;
		Len--;
	}

	//7. esperar hasta que la transmision se haya completado
	while(!(I2Cx->SR1 & I2C_SR1_TXE));
	while(!(I2Cx->SR1 & I2C_SR1_BTF));

	//8. generar la condiciÃ³n de stop
	I2Cx->CR1 |= I2C_CR1_STOP;
	return;
}

/**
 * @brief funcion de recepcion de datos
 */
void I2C_MasterReceiveData(I2C_TypeDef *I2Cx,uint8_t SlaveAddr,uint8_t *pRxbuffer, uint32_t Len){
	volatile int tmp;

	/*verificar los datos*/
	if(Len <= 0 || pRxbuffer == ((void *)0))
		return;
	/*esperar que la linea estÃƒÂ© libre*/
	while((I2Cx->SR2 & I2C_SR2_BUSY));

	//1. generar la condiciÃƒÂ³n de start
	I2Cx->CR1 |= I2C_CR1_START;
	//2. esperar que la condiciÃƒÂ³n de inicio se haya generado
	while(!(I2Cx->SR1 & I2C_SR1_SB));

	//3. enviar la direccion del esclavo
	SlaveAddr = SlaveAddr << 1;
	SlaveAddr |= 1U;			//read operation
	I2Cx->DR = SlaveAddr;
	//4. verificar que la fase de direccion se completÃƒÂ³
	while(!(I2Cx->SR1 & I2C_SR1_ADDR));
	//5. limpiar el flag
	tmp = I2Cx->SR1;
	tmp = I2Cx->SR2;
	(void)tmp;

	/* Enable Acknowledge */
	I2Cx->CR1 |=  I2C_CR1_ACK;
	while(Len>0U){
		if(Len == 1){
			/* Disable Acknowledge */
			I2Cx->CR1 &=~ I2C_CR1_ACK;
			//esperar hasta que RXNE se establesca
			while(!(I2Cx->SR1 & I2C_SR1_RXNE));
			//genera una condicion de parada
			I2Cx->CR1 |= I2C_CR1_STOP;
			//leer el dato
			*pRxbuffer = I2Cx->DR;
			Len--;
		}else{
			//esperar hasta que RXNE se establesca
			while(!(I2Cx->SR1 & I2C_SR1_RXNE));
			*pRxbuffer = I2Cx->DR;
			pRxbuffer++;
			Len--;
		}
	}

	return;
}
