/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <defines.h>
#include <stdio.h>
#include <string.h>
#include <delay.h>

#define USART2_TX		A, 2
#define USART2_RX		A, 3


uint8_t txbuffer[50];
uint8_t rxbuffer[50];
uint16_t len;
/**
 * @brief configura el USART2 a 115200
 */
void USART2_Init(void);

void USART2_GPIOInit(void);

/**
 * @brief enviar N data por el USART
 */
void USART_SendData(USART_TypeDef * USARTx,uint8_t *pTxBuffer, uint32_t Size);

/**
 * @brief enviar N data por el USART
 */
void USART_ReceiveData(USART_TypeDef * USARTx,uint8_t *pRxBuffer, uint32_t Size);

int main(void)
{
	delay_init_it();

	USART2_GPIOInit();
	USART2_Init();

	len = sprintf((char*)txbuffer,"HOLA MUNDO DESDE USART2\r\n");
	USART_SendData(USART2, txbuffer, len);

//	USART_ReceiveData(USART2, rxbuffer, 9);
//
//	len = sprintf((char*)txbuffer, "RX->%s\r\n",rxbuffer);
//	USART_SendData(USART2, txbuffer, len);
	printf("hola mundo desde USART%f \r\n",3.14);
    /* Loop forever */
	for(;;);
}

void USART2_Init(void){
	//habilitar el reloj
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
	//CONFIGURAR LOS PARAMETROS DE LA COMUNICACION
	USART2->CR1 = 0;
	//BRR
	/**
	 * FCK = 16MHZ
	 * BUAD = 115200
	 * USARTDIV = 16MHZ/(16*115200) = 8.681
	 * FRACTION ->4BITS
	 * MANTISA -> 12BITS = 0x8
	 * (OVERSAMPLING x 16)
	 * FRACTION = 0.681 * 16 = 10.896 ~ 11 -> 0xB
	 */
	USART2->BRR = 0x8U<<4 | 0xBU;

	USART2->CR1 |= USART_CR1_TE | USART_CR1_RE;
	//habilitar el USART2
	USART2->CR1 |= USART_CR1_UE;

	return;
}

void USART2_GPIOInit(void){
	RCC->AHB1ENR |= GPIOX_CLOCK(USART2_TX);
	//PA2->TX
	GPIOX_MODER(MODE_ALTER, USART2_TX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART2_TX);
	GPIOA->AFR[0] &=~ (GPIO_AFRL_AFRL2);
	GPIOA->AFR[0] |= 0x7U<<8;
	//PA3->RX
	GPIOX_MODER(MODE_ALTER, USART2_RX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART2_RX);
	GPIOA->AFR[0] &=~ (GPIO_AFRL_AFRL3);
	GPIOA->AFR[0] |= 0x7U<<12;
	//GPIOX_AFR(7U,USART2_RX);
	return;
}

/**
 * @brief enviar N data por el USART
 */
void USART_SendData(USART_TypeDef * USARTx,uint8_t *pTxBuffer, uint32_t Size){
	uint16_t *pdata;
	for(uint32_t i= 0; i<Size;i++){
		//verificar el flag TXE
		while(!(USARTx->SR & USART_SR_TXE));

		//verificar si se ve transmitir en modo de 8bit o 9bit
		if(USARTx->CR1 & USART_CR1_M){
			//enviar el dato
			pdata = (uint16_t*) pTxBuffer;
			USARTx->DR = (*pdata & (uint16_t)0x1FF);
			//Verificar la paridad
			if(!(USARTx->CR1 & USART_CR1_PCE )){
				pTxBuffer++;
				pTxBuffer++;
			}
			else{
				pTxBuffer++;
			}
		}
		else{		//modo de 8bit
			USARTx->DR = (*pTxBuffer & (uint8_t)0xFF);
			pTxBuffer++;
		}
	}
	/*esperamos que TC se ponga a 1*/
	while(!(USARTx->SR & USART_SR_TC));

	return;
}

/**
 * @brief enviar N data por el USART
 */
void USART_ReceiveData(USART_TypeDef * USARTx,uint8_t *pRxBuffer, uint32_t Size){
	for(uint32_t i= 0; i<Size;i++){
		//verificar el flag RXNE
		while(!(USARTx->SR & USART_SR_RXNE));
		//verificar si se va recibir en modo de 8bit o 9bit
		if(USARTx->CR1 & USART_CR1_M){

			/*VERIFICAR LA PARIDAD*/
			if(!(USARTx->CR1 & USART_CR1_PCE )){	//sin paridad
				*((uint16_t*) pRxBuffer) = USARTx->DR & (uint16_t) 0x1FF;
				pRxBuffer++;
				pRxBuffer++;
			}
			else{	//paridad
				*pRxBuffer = USARTx->DR & (uint8_t) 0xFF;
				pRxBuffer++;
			}
		}
		else{
			/*VERIFICAR LA PARIDAD*/
			if(!(USARTx->CR1 & USART_CR1_PCE)){
				*pRxBuffer = USARTx->DR & (uint8_t) 0xFF;
			}
			else{
				*pRxBuffer = USARTx->DR & (uint8_t) 0x7F;
			}
			pRxBuffer++;
		}
	}
	return;
}

/*************************************************/
int __io_putchar(int ch){
	uint8_t c = ch & 0xFF;
	USART_SendData(USART2, &c, 1);
	return ch;
}
