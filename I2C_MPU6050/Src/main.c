/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "Config.h"
#include "MPU6050.h"
#include "LCD.h"
/*****************************************************************************/
#define I2C1_SDA   				B, 9
#define I2C1_SCL				B, 8
#define PCLK1					42E+6	//42MHz
#define SLAVE_ADDR  			0x69
#define I2C_SCL_SPEED_SM 		100000
#define I2C_SCL_SPEED_FM4K 		400000
#define I2C_SCL_SPEED_FM2K  	200000
/**
 * Global variables
 */
uint8_t some_data[] = "We are testing I2C master Tx\n";

MPU6050_t MPU6050_1;
/**
 * @brief PLL config
 * configura el PLL  a 84MHz
 */
void PLL_Config(void);
void flash_cofig(void);
void HSE_Config(void);

/**
 * void I2C init
 */
void I2C_Init(I2C_TypeDef *I2Cx, uint32_t mode);
/**
 * @configuracion de pines del I2C
 */
void I2C1_GPIOInit(void);

void I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t SlaveAddr,uint8_t *pTxbuffer, uint32_t Len);
void I2C_MasterReceiveData(I2C_TypeDef *I2Cx,uint8_t SlaveAddr,uint8_t *pRxbuffer, uint32_t Len);


/*PROTOTIPO DE FUNCIONES*/
/**
  * @fn configura los pines necesarios
	*/
void GPIO_Config(void);
/**
  * @brief configura el MPU6050
	*/
void MPU6050_Init_Config(void);


int main(void)
{
	/*flash configuration*/
	flash_cofig();
	/*external clock configuration*/
	HSE_Config();
	/*pll configution*/
	PLL_Config();

	RCC->AHB1ENR |= GPIOX_CLOCK(LED);
	GPIOX_MODER(MODE_OUT, LED);
/******************************************************************/
	/*I2C INIT*/
	I2C1_GPIOInit();
	I2C_Init(I2C1, I2C_SCL_SPEED_FM4K);
    /* Loop forever */
/******************************************************************/
	LCD_Init(20, 4);
/*****************************************************************/

	if (MPU6050_Init(&MPU6050_1, MPU6050_Device_0, MPU6050_Accelerometer_8G, MPU6050_Gyroscope_250s) == MPU6050_Result_Ok) {
			/* Green LED on */
		GPIOX_ODR(LED) = 1;
		LCD_Printf(0, 0, "MPU6050 Inicializado\r\nde forma correcta");
	}

	/* Set new gyro sens for device 1 */
	MPU6050_SetGyroscope(&MPU6050_1, MPU6050_Gyroscope_1000s);

	delay_ms(2000);

	for(;;){
		MPU6050_ReadAll(&MPU6050_1);

		LCD_Clear();
		LCD_Printf(0, 0, "x: %d  : %.3f",MPU6050_1.Accelerometer_X, MPU6050_1.Accelerometer_X * MPU6050_1.Acce_Mult);
		LCD_Printf(0, 1, "y: %d  : %.3f",MPU6050_1.Accelerometer_Y, MPU6050_1.Accelerometer_Y * MPU6050_1.Acce_Mult);
		LCD_Printf(0, 2, "z: %d  : %.3f",MPU6050_1.Accelerometer_Z, MPU6050_1.Accelerometer_Z * MPU6050_1.Acce_Mult);
		delay_ms(500);
		GPIOX_ODR(LED) ^= 1;
	}
}


/**
 * @brief PLL config
 * configura el PLL  a 84MHz
 */
void PLL_Config(void){
	HSE_Config();
	/*configure PLL before enabling it*/
	//1. PLL clock source
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSE;	//select HSE CLOCK SOURCE
	//2. cofigure division factor (M, N, P , Q)
	/**
	 * 	f(VCO clock) = f(PLL clock input) × (PLLN / PLLM)	(192 and 432 MHz)
	 * 	f(PLL general clock output) = f(VCO clock) / PLLP  	<= 84MHz
	 */
	//M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 4U;							//VCO input frequency (1MHz to 2MHz)
	//N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 168U<<6;					//168MHZ
	//P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	RCC->PLLCFGR |= 1U<<16;						//84MHz
	//3. enable PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));			//Waint until
	/*configure AHBx, APBx precaler*/
	RCC->CFGR = 0x00000000;						//reset
	RCC->CFGR |= 0b100<<10;						//100: AHB clock divided by 2
	/*configure flash latency*/
	FLASH->ACR &=~ FLASH_ACR_LATENCY;
	FLASH->ACR |= FLASH_ACR_LATENCY_2WS;
	/*select system clock source*/
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));		//wait PLL ready as system clock
	return;
}

void HSE_Config(void){
	RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
	while(!(RCC->CR & RCC_CR_HSERDY));
	RCC->CFGR = RCC_CFGR_SW_HSE;
	while(!(RCC->CFGR & RCC_CFGR_SWS_HSE));
	SystemCoreClockUpdate();

}
void flash_cofig(void){
	FLASH->ACR |= 1<<9;							//1: Instruction cache is enabled
	FLASH->ACR |= 1<<10;						//1: Data cache is enabled
	FLASH->ACR |= 1<<8;							//1: Prefetch is enabled
	//SE HABILITAN ALGUNOS CLOCK
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	SystemCoreClockUpdate();
}


/**
 * @configuracion de pines del I2C
 */
void I2C1_GPIOInit(void){
	/*enable clock*/
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL) | GPIOX_CLOCK(I2C1_SDA);
	//PB9->I2C1_SDA, PB8->I2C1_SCL
	GPIOX_MODER(MODE_ALTER,I2C1_SCL);
	GPIOX_MODER(MODE_ALTER,I2C1_SDA);
	GPIOX_OTYPER(MODE_OT_OD,I2C1_SCL);
	GPIOX_OTYPER(MODE_OT_OD,I2C1_SDA);
	GPIOX_PUPDR(MODE_PU_UP,I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP,I2C1_SDA);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,I2C1_SCL);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,I2C1_SDA);
	GPIOX_AFR(4,I2C1_SCL);
	GPIOX_AFR(4,I2C1_SDA);
	return;
}

/**
 * void I2C init
 */
void I2C_Init(I2C_TypeDef *I2Cx, uint32_t mode){

	uint32_t tempreg = 0;
	uint16_t ccr_value = 0;


	if(I2Cx == I2C1)
		RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	else if(I2Cx == I2C2)
		RCC->APB1ENR |= RCC_APB1ENR_I2C2EN;
	else
		RCC->APB1ENR |= RCC_APB1ENR_I2C3EN;

	/*Enter reset mode  */
	I2C1->CR1 |= (1U<<15);

	/*Come out of reset mode  */
	I2C1->CR1 &=~(1U<<15);

	/*I2C param configuration*/
	//ack control bit
	I2Cx->CR1 = I2C_CR1_ACK;	//Confirmación devuelta después de recibir un byte (dirección o datos coincidentes)

	//configurar el campo FREQ de CR2
	tempreg = PCLK1 / 1000000U;
	I2Cx->CR2 = (tempreg & 0x3FU);

	//programar la propia dirección del dispositivo
	tempreg = 0;
	tempreg |= SLAVE_ADDR<<1;
	tempreg |= (1<<14);
	I2Cx->OAR1 = tempreg;

	//cálculos de CCR
	tempreg = 0;
	if(mode == I2C_SCL_SPEED_SM){  //standart mode
		ccr_value = (PCLK1 / (2 * mode));
		tempreg |= (ccr_value & 0xFFF);
	}
	else{//fast mode
		tempreg |= I2C_CCR_FS;
#if 1				//duty_2
	tempreg &=~ I2C_CCR_DUTY;
	ccr_value = (PCLK1 / ( 3 * I2C_SCL_SPEED_FM4K));
#else 				//duty_16_9
	tempreg |= I2C_CCR_DUTY;
	ccr_value = (PCLK1 / (25 * I2C_SCL_SPEED_FM4K));
#endif
	tempreg |= (ccr_value & 0xFFF);
	}
	I2Cx->CCR = tempreg;
	//TRISE Configuration
	if(mode == I2C_SCL_SPEED_SM){
		tempreg = (PCLK1 / 1000000U) + 1;
	}else{
		tempreg = ( (PCLK1 * 300) / 1000000000U ) + 1;
	}
	I2Cx->TRISE = (tempreg & 0x3F);

	/*Habilitar el modulo i2c*/
	I2Cx->CR1 |= I2C_CR1_PE;

	return;
}

void I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t SlaveAddr,uint8_t *pTxbuffer, uint32_t Len){

	volatile int tmp;

	/*verificar los datos*/
	if(Len <= 0 || pTxbuffer == ((void *)0))
		return;
	/*esperar que la linea esté libre*/
	while((I2Cx->SR2 & I2C_SR2_BUSY));

	//1. generar la condición de start
	I2Cx->CR1 |= I2C_CR1_START;
	//2. esperar que la condición de inicio se haya generado
	while(!(I2Cx->SR1 & I2C_SR1_SB));

	//3. enviar la direccion del esclavo con r/w bit
	SlaveAddr = SlaveAddr <<1 ;
	SlaveAddr &=~(1U);						//write operation
	I2Cx->DR = SlaveAddr;
	//4. verificar que la fase de direccion se completó
	while(!(I2Cx->SR1 & I2C_SR1_ADDR));
	//5. limpiar el flag
	tmp = I2Cx->SR1;
	tmp = I2Cx->SR2;
	(void)tmp;

	//6. enviar los datos
	while(Len > 0){

		while(!(I2Cx->SR1 & I2C_SR1_TXE));
		I2Cx->DR = *pTxbuffer;
		pTxbuffer++;
		Len--;
	}
	//7. esperar hasta que la transmision se complete
	while(!(I2Cx->SR1 & I2C_SR1_TXE));
	while(!(I2Cx->SR1 & I2C_SR1_BTF));

	//8. generar la condición de stop
	I2Cx->CR1 |= I2C_CR1_STOP;

	return;
}

void I2C_MasterReceiveData(I2C_TypeDef *I2Cx,uint8_t SlaveAddr,uint8_t *pRxbuffer, uint32_t Len){

	volatile int tmp;

	/*verificar los datos*/
	if(Len <= 0 || pRxbuffer == ((void *)0))
		return;
	/*esperar que la linea esté libre*/
	while((I2Cx->SR2 & I2C_SR2_BUSY));

	//1. generar la condición de start
	I2Cx->CR1 |= I2C_CR1_START;
	//2. esperar que la condición de inicio se haya generado
	while(!(I2Cx->SR1 & I2C_SR1_SB));

	//3. enviar la direccion del esclavo
	SlaveAddr = SlaveAddr << 1;
	SlaveAddr |= 1U;			//read operation
	I2Cx->DR = SlaveAddr;

	//4. verificar que la fase de direccion se completó
	while(!(I2Cx->SR1 & I2C_SR1_ADDR));

	//5. limpiar el flag
	tmp = I2Cx->SR1;
	tmp = I2Cx->SR2;
	(void)tmp;

	/* Enable Acknowledge */
	I2Cx->CR1 |=  I2C_CR1_ACK;

	while(Len>0U){
		//si solo se va reducir un byte
		if(Len == 1U){
			/* Disable Acknowledge */
			I2Cx->CR1 &=~ I2C_CR1_ACK;
			//esperar hasta que RXNE se establesca
			while(!(I2Cx->SR1 & I2C_SR1_RXNE));
			//genera una condicion de parada
			I2Cx->CR1 |= I2C_CR1_STOP;
			//leer el dato
			*pRxbuffer = I2Cx->DR;
			Len--;
		}
		else{
			//esperar hasta que RXNE se establesca
			while(!(I2Cx->SR1 & I2C_SR1_RXNE));
			*pRxbuffer = I2Cx->DR;
			pRxbuffer++;
			Len--;
		}
	}
	return;
}




