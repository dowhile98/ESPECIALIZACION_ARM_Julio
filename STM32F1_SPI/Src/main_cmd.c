/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include <strings.h>

#define COUNTOF(__BUFFER__) 	((sizeof(__BUFFER__) / sizeof(*(__BUFFER__))) - 1)
#define COMMAND_LED_CTRL        0x50
#define COMMAND_SENSOR_READ     0x51
#define COMMAND_LED_READ        0x52
#define COMMAND_PRINT          	0x53
#define COMMAND_ID_READ         0x54
#define NACK 					0xA5
#define ACK 					0xF5


#define LED_ON     				1
#define LED_OFF    				0

#define checkData(x)			ACK
/**
 * global variables
 */
uint8_t RxBuffer[100];
uint8_t board_id[] = "STM32F103C8";
uint8_t data;
uint8_t command;
uint8_t len;
uint8_t AckorNack = NACK;
uint8_t args[2];

/**
 * @brief PLL configuration 72MHz
 */
void PLL_Config(void);
/**
 * @brief SPI gpio Init
 */
void SPI1_GPIOSlaveInit(void);
/**
 * @brief configuracion de pines modo maestro
 */
void SPI1_GPIOMasterInit(void);
/**
 * @brief SPI Slave mode
 */
void SPI_SlaveInit(void);
/**
 * @brief SPI master mode
 */
void SPI1_Init(void);
/**
 * @brief SPI send data
 */
void SPI_SendData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer, uint32_t Len);
/**
 * @brief transmitirRecibir
 */
void SPI_SendReceiveData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer,uint8_t *pRxBuffer,uint32_t Len);
/**
 * @brief SPI receive data
 */
void SPI_ReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len);

/**
 * @brief master receive data
 */
void SPI_MasterReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len);

/**
 * @brief delay
 */
void delay_ms(uint32_t delay);
int main(void)
{
	/*pll config to 72MHz*/
	PLL_Config();
/****************************************************************************/
	/*led init*/
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
	GPIOC->CRH &=~(GPIO_CRH_CNF13 | GPIO_CRH_MODE13);
	GPIOC->CRH |= GPIO_CRH_MODE13;
	GPIOC->BSRR |= GPIO_BSRR_BS13;
/****************************************************************************/
	/*SPI Init*/
	SPI1_GPIOSlaveInit();
	SPI_SlaveInit();
/****************************************************************************/

    /* Loop forever */
	for(;;){
		//RECEIVE DATA SLAVE
		SPI_ReceiveData(SPI1, &command, 1);
		AckorNack = checkData(command);
		//se envia la respues al comando
		SPI_SendData(SPI1, &AckorNack, 1);

		SPI_ReceiveData(SPI1, &len, 1);			//dummy byte

		if(command == COMMAND_LED_CTRL){
			SPI_ReceiveData(SPI1, args, 2);

			if(args[1] == LED_ON){
				GPIOC->ODR &=~ (1U<<args[0]);
			}else if(args[1] == LED_OFF){
				GPIOC->ODR |= 1U<<args[0];
			}
		}
	}
}
/**
 * @brief SPI gpio Init
 */
void SPI1_GPIOSlaveInit(void){
	/*PA4 -> SPI1_NSS, PA5 -> SPI1_SCK, PA6 -> SPI1_MISO, PA7 -> SPI1_MOSI*/
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	/*PINOUT CONFIGURATION*/
	//PA4 -> Input floating
	GPIOA->CRL &=~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4);
	GPIOA->CRL |= GPIO_CRL_CNF4_0;
	//PA5 -> Input floating
	GPIOA->CRL &=~(GPIO_CRL_CNF5 | GPIO_CRL_MODE5);
	GPIOA->CRL |= GPIO_CRL_CNF5_0;
	//PA6-> Alternate function push-pull
	GPIOA->CRL &=~ (GPIO_CRL_CNF6 | GPIO_CRL_MODE6);
	GPIOA->CRL |= GPIO_CRL_CNF6_1 | GPIO_CRL_MODE6;
	//PA7-> Input floating
	GPIOA->CRL &=~ (GPIO_CRL_CNF7 | GPIO_CRL_MODE7);
	GPIOA->CRL |= GPIO_CRL_CNF7_0;
	return;
}
/**
 * @brief configuracion de pines modo maestro
 */
void SPI1_GPIOMasterInit(void){
	/*PA4 -> SPI1_NSS, PA5 -> SPI1_SCK, PA6 -> SPI1_MISO, PA7 -> SPI1_MOSI*/
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	//PA4 -> Alternate function push-pull
	GPIOA->CRL &=~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4);
	GPIOA->CRL |= GPIO_CRL_CNF4_1 | GPIO_CRL_MODE4;
	//PA5 -> Alternate function push-pull
	GPIOA->CRL &=~(GPIO_CRL_CNF5 | GPIO_CRL_MODE5);
	GPIOA->CRL |= GPIO_CRL_CNF5_1 | GPIO_CRL_MODE5;
	//PA6-> Input floating
	GPIOA->CRL &=~ (GPIO_CRL_CNF6 | GPIO_CRL_MODE6);
	GPIOA->CRL |= GPIO_CRL_CNF6_0;
	//PA7-> Alternate function push-pull
	GPIOA->CRL &=~ (GPIO_CRL_CNF7 | GPIO_CRL_MODE7);
	GPIOA->CRL |= GPIO_CRL_CNF7_1 | GPIO_CRL_MODE7;
	return;
}
/**
 * @brief SPI Slave mode
 */
void SPI_SlaveInit(void){
	/*enable clock*/
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

	/*SPI SLAVE MODE CONFIGURATION*/
	SPI1->CR1 = 0;						//RESET
	/*1. seleccionar el formato de datos*/
	/*2. seleccionar la polaridad CPOL y CHPA*/
	SPI1->CR1 |= SPI_CR1_CPHA | SPI_CR1_CPOL;
	/*3. seleccionar el formato de la trama (MSB or LSB first)*/
	/*4. seleccionar el manejo del pin NSS*/
//	SPI1->CR1 |= SPI_CR1_SSM;
//	SPI1->CR1 |= SPI_CR1_SSI;
	/*5. seleccionar el modo esclavo (clear MSTR bit)*/
	SPI1->CR1 &=~ (SPI_CR1_MSTR);
	/*HABILITAMOS EL SPI*/
	SPI1->CR1 |= SPI_CR1_SPE;
	return;
}

/**
 * @brief SPI master mode
 */
void SPI1_Init(void){
	/*enable clock*/
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
	/*1. seleccionar el clock buad rate*/
	SPI1->CR1 &=~ (SPI_CR1_BR);			//Fpclk/2
	SPI1->CR1 |= SPI_CR1_BR_1 | SPI_CR1_BR_0;
	/*2. configurar CPOL y CPHA*/
	//CPOL = 0
	//CPHA = 0
	SPI1->CR1 &=~ (SPI_CR1_CPHA | SPI_CR1_CPOL);
	/*3. Seleccionar el tamaÃ±o de la trama*/
	SPI1->CR1 &=~(SPI_CR1_DFF);			//8bit
	/*4. configurar LSBFIRST (si fuera necesario)*/
	SPI1->CR1 &=~ (SPI_CR1_LSBFIRST);	//MSB first
	/*5. configurar el manejo del NSS*/
	SPI1->CR1 &=~ (SPI_CR1_SSM);
	SPI1->CR2 |= SPI_CR2_SSOE;
	/*6. Configurar TI si fuera necesario*/
	/*7. Habilitar  el bit MSTR*/
	SPI1->CR1 |= SPI_CR1_MSTR;
	/*8. habilitar el SPI*/
	SPI1->CR1 |= SPI_CR1_SPE;
	return;
}

/**
 * @brief SPI send data
 */
void SPI_SendData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer, uint32_t Len){
	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));
		//2. Verificar el bit DFF
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			SPIx->DR = *((uint16_t*)pTxBuffer);
			Len -= 2;
			(uint16_t*)pTxBuffer++;
		}else{
			//8bit
			*((__IO uint8_t*)&SPIx->DR) = *pTxBuffer;
			pTxBuffer++;
			Len--;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);
	return;
}

/**
 * @brief transmitirRecibir
 */
void SPI_SendReceiveData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer,uint8_t *pRxBuffer,uint32_t Len){
	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			SPIx->DR = *((uint16_t*)pTxBuffer);

			//wait for RXNE
			while(!(SPIx->SR & SPI_SR_RXNE));
			*((uint16_t*)pRxBuffer) = SPIx->DR ;

			Len -= 2;
			(uint16_t*)pTxBuffer++;
			(uint16_t*)pRxBuffer++;
		}else{
			*((__IO uint8_t*)&SPIx->DR) = *pTxBuffer;

			//wait for RXNE
			while(!(SPIx->SR & SPI_SR_RXNE));
			*(pRxBuffer) = SPIx->DR;

			pTxBuffer++;
			pRxBuffer++;
			Len--;
		}
	}


	return;
}

/**
 * @brief SPI receive data
 */
void SPI_ReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len){
	while(Len>0){
		//wait until RXNE is set
		while(!(SPIx->SR & SPI_SR_RXNE));

		//2. check the DFF bit in CR1
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit DFF
			//1. load the data from DR to Rxbuffer address
			*((uint16_t*)pRxBuffer) = SPIx->DR;
			Len -= 2;
			(uint16_t*)pRxBuffer++;
		}else{
			//8 bit DFF
			*(pRxBuffer) = SPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);

	return;
}


/**
 * @brief master receive data
 */
void SPI_MasterReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len){

	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));

		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			//the clock is controlled by master
			//thus, the master must send a byte
			SPIx->DR = (uint16_t) 0xFFFF;			//write dummy
			//data to the slave to start the clock
			while(!(SPIx->SR & SPI_SR_RXNE));
			*((uint16_t*)pRxBuffer) = SPIx->DR;

			Len -= 2;
			(uint16_t*)pRxBuffer++;
		}else{
			//16 bit data
			//the clock is controlled by master
			//thus, the master must send a byte
			*((__IO uint8_t*)&SPIx->DR) = 0xFF;		//dummy byte
			//data to the slave to start the clock
			while(!(SPIx->SR & SPI_SR_RXNE));
			*(pRxBuffer) = SPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);
	return;
}

/**
 * @brief delay
 */
void delay_ms(uint32_t delay){
	SysTick->CTRL = 0;
	SysTick->LOAD = SystemCoreClock/1000 - 1;
	SysTick->VAL = 0;
	SysTick->CTRL |= 1U<<2 | 1U;
	for(uint32_t i = 0;i<delay;i++){
		while(!(SysTick->CTRL & 1u<<16));
	}
	SysTick->CTRL = 0;
	return;
}

void PLL_Config(void){
	/*cambiar la fuente de reloj*/
	RCC->CFGR &=~ RCC_CFGR_SW;									//HSI selected as sysclk
	/*1 deshabilitar el pll*/
	RCC->CR &=~ RCC_CR_PLLON;
	while(RCC->CR & RCC_CR_PLLRDY);
	/*2. seleccionar la fuente de reloj del pll*/
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	RCC->CFGR |= RCC_CFGR_PLLSRC;						//HSE Selected as PLL input clock
	/*3. configurar PLLMUL*/
	RCC->CFGR &=~ (RCC_CFGR_PLLMULL);
	RCC->CFGR |= RCC_CFGR_PLLMULL9;							// PLL input clock x 9 = 72MHz
	/*4. Aplicar los prescaler necesarios*/
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CR |= RCC_CFGR_PPRE1_DIV2;							//HCLK / 2
	/*5 configurar la latencia de la flash*/
	FLASH->ACR &=~ FLASH_ACR_LATENCY;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;
	/*6. encender la pll*/
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	/*7. Seleccionar la fuente de reloj*/
	RCC->CFGR &=~ RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));
	SystemCoreClockUpdate();
}
