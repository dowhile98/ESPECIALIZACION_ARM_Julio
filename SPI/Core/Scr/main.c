/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
/* Private includes ----------------------------------------------------------*/
#include "RCC.h"
#include "Config.h"
#include <stdio.h>
#include "gui.h"
#include "bmp.h"
/* Private typedef -----------------------------------------------------------*/


/* Private define ------------------------------------------------------------*/
#define SPI1_SCK		A, 5
#define SPI1_MOSI		A, 7
#define SPI1_MISO		A, 6
#define SPI1_NSS		B, 6

#define COUNTOF(__BUFFER__) 	((sizeof(__BUFFER__) / sizeof(*(__BUFFER__))) - 1)
/* Private macro -------------------------------------------------------------*/
#define USE_SWV			1  //Serial wire viewer
/* Private variables ---------------------------------------------------------*/

/* Private function prototypes -----------------------------------------------*/
/**
 * @brief configuracion de pines necesarios para el SPI1
 */
void SPI1_GPIOInit(void);

void SPI_Init(SPI_TypeDef *SPIx);
/**
 * @brief SPI send data
 */
void SPI_SendData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer, uint32_t Len);
/**
 * @brief transmitirRecibir
 */
void SPI_SendReceiveData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer,uint8_t *pRxBuffer,uint32_t Len);
/**
 * @brief SPI receive data
 */
void SPI_ReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len);
/**
 * @brief master receive data
 */
void SPI_MasterReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len);
/* Private user code ---------------------------------------------------------*/

uint8_t txt[] = "Hola mundo SPI1";
/* External variables --------------------------------------------------------*/


int main(void)
{

	/*LED INIT*/
/******************************************************************************/
	RCC->AHB1ENR |= GPIOX_CLOCK(SPI1_NSS);
	GPIOX_MODER(MODE_OUT,SPI1_NSS);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,SPI1_NSS);
	GPIOX_ODR(SPI1_NSS) = 1;
/******************************************************************************/
	SPI1_GPIOInit();
	SPI_Init(SPI1);		//CONFIGURA EL SPI1
//	printf("CONFIGURACION SP1 CORRECTA\n");
/******************************************************************************/
//	GPIOX_ODR(SPI1_NSS) = 0;		//CS ON
//	SPI_SendData(SPI1, txt, COUNTOF(txt));
//	GPIOX_ODR(SPI1_NSS) = 1;		//CS OFF
//	printf("DATO ENVIADO CORRECTAMENTE\n");
	OLED_Init();
	OLED_Clear(0);
	GUI_DrawBMP(0, 0, pajaro.width, pajaro.height, (uint8_t*)pajaro.data, 1);
    /* Loop forever */
	for(;;){



	}
}

/**
 * @brief configuracion de pines necesarios para el SPI1
 */
void SPI1_GPIOInit(void){
	RCC->AHB1ENR |= GPIOX_CLOCK(SPI1_SCK);
	//CONFIGURAR
	GPIOX_MODER(MODE_ALTER,SPI1_SCK);
	GPIOX_AFR(5,SPI1_SCK);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,SPI1_SCK);

	GPIOX_MODER(MODE_ALTER,SPI1_MISO);
	GPIOX_AFR(5,SPI1_MISO);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,SPI1_MISO);

	GPIOX_MODER(MODE_ALTER,SPI1_MOSI);
	GPIOX_AFR(5,SPI1_MOSI);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,SPI1_MOSI);

}


void SPI_Init(SPI_TypeDef *SPIx){
	/*enable clock*/
	if(SPIx == SPI1)
		RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
	else if(SPIx == SPI2)
		RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;
	else
		RCC->APB1ENR |= RCC_APB1ENR_SPI3EN;

/******************************************************************************/
	//1. Configurar el baudrate
	SPIx->CR1 &=~ SPI_CR1_BR;			//Fpclk / 2 = 8MHz
	SPIx->CR1 |= SPI_CR1_BR_0;			//Fpclk / 4 = 4MHz
	//2. configurar la poliridad y la fasse del reloj
	//CPOL
	SPIx->CR1 &=~ SPI_CR1_CPOL;			//CPOL = 0
	//CPHA
	SPIx->CR1 &=~ SPI_CR1_CPHA;			//CPHA = 0
	/*3. seleccionar la longitud de la trama*/
	SPIx->CR1 &=~ SPI_CR1_DFF;			//8-bit
	/*4. configurar LSB o MSB first*/
	SPIx->CR1 &=~ SPI_CR1_LSBFIRST;		//MSB FIRST
	/*5. configura el mamejo del pin NSS*/
	SPIx->CR1 |= SPI_CR1_SSM;			//software managment
	SPIx->CR1 |= SPI_CR1_SSI;
	/*6 configurar el modo TI si es que fuera necesario	 */

	/*7. habilita el modo maestro*/
	SPIx->CR1 |= SPI_CR1_MSTR;			//habilita el modo maestro
	/*8. habilitar el spi*/
	SPIx->CR1 |= SPI_CR1_SPE;			//habilita el spi para tx y rx
}

/**
 * @brief SPI send data
 */
void SPI_SendData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer, uint32_t Len){
	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & 1U<<1));
		//2. Verificar el bit DFF
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			SPIx->DR = *((uint16_t*)pTxBuffer);
			Len -= 2;
			(uint16_t*)pTxBuffer++;
		}else{
			//8bit
			*((__IO uint8_t*)&SPIx->DR) = *pTxBuffer;
			pTxBuffer++;
			Len--;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);
	return;
}

/**
 * @brief transmitirRecibir
 */
void SPI_SendReceiveData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer,uint8_t *pRxBuffer,uint32_t Len){
	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			SPIx->DR = *((uint16_t*)pTxBuffer);

			//wait for RXNE
			while(!(SPIx->SR & SPI_SR_RXNE));
			*((uint16_t*)pRxBuffer) = SPIx->DR ;

			Len -= 2;
			(uint16_t*)pTxBuffer++;
			(uint16_t*)pRxBuffer++;
		}else{
			*((__IO uint8_t*)&SPIx->DR) = *pTxBuffer;

			//wait for RXNE
			while(!(SPIx->SR & SPI_SR_RXNE));
			*(pRxBuffer) = SPIx->DR;

			pTxBuffer++;
			pRxBuffer++;
			Len--;
		}
	}


	return;
}

/**
 * @brief SPI receive data
 */
void SPI_ReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len){
	while(Len>0){
		//wait until RXNE is set
		while(!(SPIx->SR & SPI_SR_RXNE));

		//2. check the DFF bit in CR1
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit DFF
			//1. load the data from DR to Rxbuffer address
			*((uint16_t*)pRxBuffer) = SPIx->DR;
			Len -= 2;
			(uint16_t*)pRxBuffer++;
		}else{
			//8 bit DFF
			*(pRxBuffer) = SPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);

	return;
}


/**
 * @brief master receive data
 */
void SPI_MasterReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len){

	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));

		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			//the clock is controlled by master
			//thus, the master must send a byte
			SPIx->DR = (uint16_t) 0xFFFF;			//write dummy
			//data to the slave to start the clock
			while(!(SPIx->SR & SPI_SR_RXNE));
			*((uint16_t*)pRxBuffer) = SPIx->DR;

			Len -= 2;
			(uint16_t*)pRxBuffer++;
		}else{
			//16 bit data
			//the clock is controlled by master
			//thus, the master must send a byte
			*((__IO uint8_t*)&SPIx->DR) = 0xFF;		//dummy byte
			//data to the slave to start the clock
			while(!(SPIx->SR & SPI_SR_RXNE));
			*(pRxBuffer) = SPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);
	return;
}


/******************************************************************************/
int __io_putchar(int ch){
#if (USE_SWV== 1)
	ITM_SendChar((uint32_t)ch);
#else
	uint8_t c = ch & 0xFF;
	while(!(USART2->SR & USART_SR_TXE));  //espera hasta que usart este listo para transmitir otro byte
	USART2->DR = c;
#endif
	return ch;
}

